import { state } from './state.js';
import { renderBoard, setupDelegatedEvents, applyStateUpdate } from './dom.js';
import { openEditModal, saveModalDetails } from './modals.js';
// GITHUB INTEGRATIE: Imports toegevoegd
import { saveToFile, loadFromFile, exportToCSV, exportHD, saveToGitHub, loadFromGitHub } from './io.js';
import { Toast } from './toast.js';

const $ = (id) => document.getElementById(id);

const pickEl = (...selectors) => {
  for (const sel of selectors) {
    if (!sel) continue;
    const byId = document.getElementById(sel);
    if (byId) return byId;
    const bySel = document.querySelector(sel);
    if (bySel) return bySel;
  }
  return null;
};

const bindClickEl = (el, handler) => {
  if (!el) return;
  el.addEventListener('click', (e) => {
    e.preventDefault();
    handler(e);
  });
};

const bindClick = (id, handler) => {
  const el = $(id);
  if (!el) return;
  el.addEventListener('click', (e) => {
    e.preventDefault();
    handler(e);
  });
};

const safeToast = (msg, type = 'info', ms) => {
  if (!Toast || typeof Toast.show !== 'function') return;
  Toast.show(msg, type, ms);
};

/** Initializes the toast UI if available. */
const initToast = () => {
  try {
    if (Toast && typeof Toast.init === 'function') Toast.init();
  } catch (e) {
    console.warn('Toast init failed', e);
  }
};

/** Persists the current modal state into data without closing it. */
const syncOpenModal = () => {
  const modal = $('editModal');
  if (!modal) return;
  const isOpen = modal.style.display && modal.style.display !== 'none';
  if (!isOpen) return;

  try {
    saveModalDetails(false);
  } catch (e) {
    console.warn('Modal sync failed', e);
  }
};

/** Renames the active sheet using a prompt and persists state. */
const renameActiveSheet = () => {
  syncOpenModal();

  const currentName = state.activeSheet?.name || '';
  const newName = prompt('Hernoem proces:', currentName);
  if (!newName || !newName.trim() || newName.trim() === currentName) return;
  if (typeof state.renameSheet === 'function') state.renameSheet(newName.trim());
  safeToast('Naam gewijzigd', 'success');
};

/** Returns a stable identifier for the active sheet if present. */
const getActiveSheetKey = () => {
  const s = state.activeSheet;
  return s?.id ?? s?.name ?? null;
};

/** Attempts to trigger a reindex routine in state after sheet ordering changes. */
const tryReindexAfterSheetOrderChange = () => {
  const fns = [
    state?.reindexAfterSheetOrderChange,
    state?.reindexAfterSheetReorder,
    state?.reindexDerivedIds,
    state?.reindexAll
  ].filter((fn) => typeof fn === 'function');

  if (fns.length) {
    try {
      fns[0].call(state);
    } catch (e) {
      console.warn('Reindex failed', e);
    }
  }
};

/** Produces a readable listing of current sheets for reorder prompts. */
const buildSheetOrderPromptText = () => {
  const sheets = Array.isArray(state?.data?.sheets) ? state.project.sheets : [];
  const lines = sheets.map((s, i) => `${i + 1}. ${String(s?.name || `Proces ${i + 1}`)}`);
  return `Huidige volgorde:\n${lines.join('\n')}\n\nNieuwe volgorde (komma-gescheiden indices, bv: 2,1,3):`;
};

/** Validates that an array is a permutation of 1..n. */
const isPermutation1ToN = (arr, n) => {
  if (!Array.isArray(arr) || arr.length !== n) return false;
  const seen = new Set();
  for (const x of arr) {
    if (!Number.isInteger(x) || x < 1 || x > n) return false;
    if (seen.has(x)) return false;
    seen.add(x);
  }
  return seen.size === n;
};

/** Reorders the sheets in state based on a user-provided permutation. */
const reorderSheetsByPrompt = () => {
  syncOpenModal();

  const sheets = Array.isArray(state?.data?.sheets) ? state.project.sheets : [];
  const n = sheets.length;
  if (n <= 1) return;

  const input = prompt(buildSheetOrderPromptText(), Array.from({ length: n }, (_, i) => i + 1).join(','));
  if (!input || !input.trim()) return;

  const order = input
    .split(',')
    .map((x) => x.trim())
    .filter((x) => x.length > 0)
    .map((x) => parseInt(x, 10))
    .filter((x) => Number.isFinite(x));

  if (!isPermutation1ToN(order, n)) {
    safeToast('Ongeldige volgorde. Gebruik elke index precies 1x (1 t/m N).', 'error', 2200);
    return;
  }

  const activeKey = getActiveSheetKey();

  if (typeof state.reorderSheets === 'function') {
    try {
      state.reorderSheets(order.map((x) => x - 1));
      tryReindexAfterSheetOrderChange();
      safeToast('Volgorde bijgewerkt', 'success');
      return;
    } catch (e) {
      console.warn('state.reorderSheets failed', e);
    }
  }

  try {
    const nextSheets = order.map((x) => sheets[x - 1]);
    state.project.sheets = nextSheets;

    const activeAfter = nextSheets.find((s) => (s?.id ?? s?.name ?? null) === activeKey);
    if (activeAfter) {
      if (typeof state.setActiveSheet === 'function') state.setActiveSheet(activeAfter.id ?? activeAfter.name);
      else state.activeSheet = activeAfter;
    } else {
      if (typeof state.setActiveSheet === 'function') state.setActiveSheet(nextSheets[0]?.id ?? nextSheets[0]?.name);
      else state.activeSheet = nextSheets[0];
    }

    if (typeof state.save === 'function') state.save();
    if (typeof state.saveProject === 'function') state.saveProject();
    if (typeof state.persist === 'function') state.persist();

    tryReindexAfterSheetOrderChange();
    renderBoard(openEditModal);
    safeToast('Volgorde bijgewerkt', 'success');
  } catch (e) {
    console.warn('Fallback reorder failed', e);
    safeToast('Volgorde wijzigen mislukt', 'error', 2200);
  }
};

let mergeRefreshTimer = null;

/** Ensures the merge overlay layer exists and returns its element. */
const ensureMergeLayer = () => {
  const wrapper = $('board-content-wrapper');
  if (!wrapper) return null;

  const wrapperStyle = getComputedStyle(wrapper);
  if (wrapperStyle.position === 'static') {
    wrapper.style.position = 'relative';
  }

  let layer = $('merge-layer');
  if (!layer) {
    layer = document.createElement('div');
    layer.id = 'merge-layer';
    layer.setAttribute('aria-hidden', 'true');
    wrapper.insertBefore(layer, $('cols') || null);
  }

  Object.assign(layer.style, {
    position: 'absolute',
    inset: '0',
    pointerEvents: 'none',
    zIndex: '50'
  });

  return layer;
};

/** Returns the rendered column elements for the current board view. */
const getColumnElements = () => {
  const colsRoot = $('cols');
  if (!colsRoot) return [];
  return Array.from(colsRoot.querySelectorAll(':scope > .col'));
};

/** Returns the sticky element at a given column element and slot index. */
const getStickyAt = (colEl, slotIdx) => {
  if (!colEl) return null;
  const slots = colEl.querySelector('.slots');
  if (!slots) return null;
  const slot = slots.querySelector(`:scope > .slot:nth-child(${slotIdx + 1})`);
  if (!slot) return null;
  return slot.querySelector(':scope > .sticky');
};

/** Shows or hides underlying stickies while preserving layout. */
const setUnderlyingVisibility = (stickyEls, visible) => {
  for (const el of stickyEls) {
    if (!el) continue;
    if (visible) {
      el.style.visibility = '';
      el.style.opacity = '';
    } else {
      el.style.visibility = 'hidden';
      el.style.opacity = '0';
    }
  }
};

/** Builds a merged sticky element for overlay rendering. */
const buildMergedStickyEl = (textValue) => {
  const merged = document.createElement('div');
  merged.id = 'merged-approval-output';
  merged.className = 'sticky merged-sticky';
  merged.style.position = 'absolute';
  merged.style.pointerEvents = 'auto';

  merged.innerHTML = `
    <div class="sticky-grip"></div>
    <div class="sticky-content">
      <div class="text" spellcheck="false"></div>
    </div>
    <div class="sticky-badge label-tr">MERGED</div>
  `;

  const textEl = merged.querySelector('.text');
  if (textEl) textEl.textContent = textValue || '';

  return merged;
};

/** Synchronizes a legacy merged overlay example for the active sheet. */
const syncMergedApprovalOutput = () => {
  const layer = ensureMergeLayer();
  if (!layer) return;

  layer.innerHTML = '';

  const cols = getColumnElements();
  if (cols.length < 4) return;

  const SLOT_OUTPUT = 4;
  const targetColIdxs = [1, 2, 3];

  const stickyEls = targetColIdxs.map((i) => getStickyAt(cols[i], SLOT_OUTPUT));
  if (stickyEls.some((el) => !el)) return;

  const dataTexts = targetColIdxs.map((i) => {
    const t = state.activeSheet?.columns?.[i]?.slots?.[SLOT_OUTPUT]?.text;
    return typeof t === 'string' ? t.trim() : '';
  });

  const domTexts = stickyEls.map((el) => {
    const t = el?.querySelector('.text')?.textContent;
    return typeof t === 'string' ? t.trim() : '';
  });

  const texts = dataTexts.every((t) => t) ? dataTexts : domTexts;
  const nonEmpty = texts.filter((t) => t.length > 0);
  if (nonEmpty.length === 0) return;

  const first = texts[0];
  const allSame = texts.every((t) => t === first);
  if (!allSame) {
    setUnderlyingVisibility(stickyEls, true);
    return;
  }

  const layerRect = layer.getBoundingClientRect();
  const rects = stickyEls.map((el) => el.getBoundingClientRect());

  const left = Math.min(...rects.map((r) => r.left));
  const top = Math.min(...rects.map((r) => r.top));
  const right = Math.max(...rects.map((r) => r.right));
  const bottom = Math.max(...rects.map((r) => r.bottom));

  const mergedEl = buildMergedStickyEl(first);

  const inset = 0;
  mergedEl.style.left = `${left - layerRect.left + inset}px`;
  mergedEl.style.top = `${top - layerRect.top + inset}px`;
  mergedEl.style.width = `${right - left - inset * 2}px`;
  mergedEl.style.height = `${bottom - top - inset * 2}px`;

  mergedEl.addEventListener('click', (e) => {
    e.preventDefault();
    e.stopPropagation();
    const target = stickyEls[0];
    if (target) {
      target.dispatchEvent(new MouseEvent('click', { bubbles: true, cancelable: true }));
    }
  });

  layer.appendChild(mergedEl);
  setUnderlyingVisibility(stickyEls, false);
};

/** Schedules a merge overlay refresh with an optional delay. */
const scheduleMergeRefresh = (delay = 0) => {
  // FIX: Niet refreshen als we in de merged note aan het typen zijn
  const activeEl = document.activeElement;
  if (activeEl && activeEl.closest('#merged-approval-output')) {
    return;
  }

  if (mergeRefreshTimer) clearTimeout(mergeRefreshTimer);
  mergeRefreshTimer = setTimeout(() => {
    try {
      syncMergedApprovalOutput();
    } catch (e) {
      console.warn('Merge refresh failed', e);
    }
  }, delay);
};

/** Sets up project title input bindings to state. */
const setupProjectTitle = () => {
  const titleInput = $('boardTitle');
  if (!titleInput) return;

  titleInput.addEventListener('input', (e) => {
    if (typeof state.updateProjectTitle === 'function') state.updateProjectTitle(e.target.value);
  });

  titleInput.addEventListener('blur', () => {
    if (typeof state.updateProjectTitle === 'function') state.updateProjectTitle(titleInput.value);
  });
};

/** Sets up sheet selection and CRUD controls including optional reorder binding. */
const setupSheetControls = () => {
  const sheetSelect = $('sheetSelect');
  if (sheetSelect) {
    sheetSelect.addEventListener('change', (e) => {
      syncOpenModal();
      if (typeof state.setActiveSheet === 'function') state.setActiveSheet(e.target.value);
      safeToast(`Gewisseld naar: ${state.activeSheet?.name || ''}`, 'info', 1000);
      scheduleMergeRefresh(50);
    });
  }

  const btnRename = pickEl('btnRenameSheet', '#btnRenameSheet', "[data-action='rename-sheet']");
  bindClickEl(btnRename, renameActiveSheet);

  document.addEventListener('dblclick', (e) => {
    if (e.target && e.target.id === 'board-header-display') renameActiveSheet();
  });

  const btnReorder = pickEl('btnReorderSheets', '#btnReorderSheets', "[data-action='reorder-sheets']", 'btnSortSheets', '#btnSortSheets');
  bindClickEl(btnReorder, () => {
    reorderSheetsByPrompt();
    scheduleMergeRefresh(80);
  });

  const btnAdd = pickEl('btnAddSheet', '#btnAddSheet', "[data-action='add-sheet']", '#addSheetBtn');
  bindClickEl(btnAdd, () => {
    syncOpenModal();
    const name = prompt('Nieuw procesblad naam:', `Proces ${state.project.sheets.length + 1}`);
    if (!name || !name.trim()) return;
    if (typeof state.addSheet === 'function') state.addSheet(name.trim());
    safeToast('Procesblad toegevoegd', 'success');
    scheduleMergeRefresh(50);
  });

  const btnDel = pickEl('btnDelSheet', '#btnDelSheet', "[data-action='delete-sheet']", '#deleteSheetBtn');
  bindClickEl(btnDel, () => {
    syncOpenModal();

    if (state.project.sheets.length <= 1) {
      safeToast('Laatste blad kan niet verwijderd worden', 'error');
      return;
    }
    if (!confirm(`Weet je zeker dat je "${state.activeSheet.name}" wilt verwijderen?`)) return;
    if (typeof state.deleteSheet === 'function') state.deleteSheet();
    safeToast('Procesblad verwijderd', 'info');
    scheduleMergeRefresh(50);
  });

  document.addEventListener('visibilitychange', () => {
    if (document.hidden) syncOpenModal();
  });
};

/* ==========================================================================
   GITHUB CLOUD UI HANDLERS
   ========================================================================== */

/** Setup functie voor GitHub configuratie prompt */
const setupGitHubConfig = () => {
  const t = prompt("GitHub Token:", localStorage.getItem('gh_token') || '');
  if (t === null) return; // Geannuleerd
  const o = prompt("GitHub Gebruikersnaam (Owner):", localStorage.getItem('gh_owner') || '');
  const r = prompt("Repository naam:", localStorage.getItem('gh_repo') || '');
  
  if(t && o && r) {
    localStorage.setItem('gh_token', t);
    localStorage.setItem('gh_owner', o);
    localStorage.setItem('gh_repo', r);
    safeToast('Instellingen opgeslagen!', 'success');
  }
};

/** Koppel acties aan cloud knoppen */
const setupCloudActions = () => {
  // Knop: Opslaan naar GitHub
  bindClick('ghSaveBtn', async () => {
    syncOpenModal();
    const btn = document.getElementById('ghSaveBtn');
    const oldText = btn ? btn.innerText : '';
    if (btn) btn.innerText = 'Bezig...';
    
    try {
      await saveToGitHub();
      safeToast('Succesvol opgeslagen in GitHub Repo!', 'success');
    } catch (e) {
      console.error(e);
      safeToast('Fout: ' + e.message, 'error', 4000);
    } finally {
      if (btn) btn.innerText = oldText;
    }
  });

  // Knop: Laden van GitHub
  bindClick('ghLoadBtn', async () => {
    syncOpenModal();
    if(!confirm("Huidige wijzigingen overschrijven met versie van GitHub?")) return;
    try {
      await loadFromGitHub();
      safeToast('Laatste versie ingeladen!', 'success');
      renderBoard(openEditModal); 
      scheduleMergeRefresh(100);
    } catch (e) {
      console.error(e);
      safeToast('Fout bij laden: ' + e.message, 'error', 4000);
    }
  });

  // Knop: Instellingen
  bindClick('ghSetupBtn', setupGitHubConfig);
};

/** Sets up toolbar actions for save/load/export and clears. */
const setupToolbarActions = () => {
  bindClick('saveBtn', async () => {
    syncOpenModal();
    await saveToFile();
    safeToast('Project opgeslagen', 'success');
  });

  bindClick('exportCsvBtn', () => {
    syncOpenModal();
    exportToCSV();
    safeToast('Excel export gereed', 'success');
  });

  bindClick('exportBtn', async () => {
    syncOpenModal();
    await exportHD();
    safeToast('Screenshot gemaakt', 'success');
  });

  bindClick('loadBtn', () => {
    const inp = $('fileInput');
    if (inp) inp.click();
  });

  const fileInput = $('fileInput');
  if (fileInput) {
    fileInput.addEventListener('change', (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      loadFromFile(file, () => {
        fileInput.value = '';
        safeToast('Project geladen', 'success');
        scheduleMergeRefresh(100);
      });
    });
  }

  bindClick('clearBtn', () => {
    syncOpenModal();
    if (!confirm('⚠️ Pas op: Alles wissen?')) return;
    localStorage.clear();
    location.reload();
  });
};

/** Sets up zoom controls and triggers overlay recalculation. */
const setupZoom = () => {
  let zoomLevel = 1;

  const updateZoom = () => {
    const boardEl = $('board');
    if (!boardEl) return;

    zoomLevel = Math.max(0.4, Math.min(2.0, zoomLevel));
    boardEl.style.transform = `scale(${zoomLevel})`;

    const zoomDisplay = $('zoomDisplay');
    if (zoomDisplay) zoomDisplay.textContent = `${Math.round(zoomLevel * 100)}%`;

    setTimeout(() => {
      window.dispatchEvent(new Event('resize'));
      scheduleMergeRefresh(0);
    }, 50);
  };

  bindClick('zoomIn', () => {
    zoomLevel += 0.1;
    updateZoom();
  });

  bindClick('zoomOut', () => {
    zoomLevel -= 0.1;
    updateZoom();
  });

  updateZoom();
};

/** Sets up the topbar menu collapse toggle. */
const setupMenuToggle = () => {
  bindClick('menuToggle', () => {
    const topbar = $('topbar');
    if (!topbar) return;

    const viewportEl = $('viewport');
    const icon = document.querySelector('#menuToggle .toggle-icon');

    const isCollapsed = topbar.classList.toggle('collapsed');
    if (viewportEl) viewportEl.classList.toggle('expanded-view');
    if (icon) icon.style.transform = isCollapsed ? 'rotate(180deg)' : 'rotate(0deg)';

    scheduleMergeRefresh(50);
  });
};

/** Sets up the column visibility manager modal. */
const setupColumnManager = () => {
  bindClick('btnManageCols', () => {
    syncOpenModal();

    const list = $('colManagerList');
    const modal = $('colManagerModal');
    if (!list || !modal) return;

    list.innerHTML = '';

    state.activeSheet.columns.forEach((col, idx) => {
      const raw = col.slots?.[3]?.text || '';
      const procText = raw ? `${raw.substring(0, 25)}${raw.length > 25 ? '...' : ''}` : '<i>(Leeg)</i>';

      const item = document.createElement('div');
      item.className = 'col-manager-item';
      item.innerHTML = `
        <span style="font-size:13px; color:#ddd;">
          <strong>Kolom ${idx + 1}</strong>: ${procText}
        </span>
        <input type="checkbox" ${col.isVisible !== false ? 'checked' : ''} style="cursor:pointer; transform:scale(1.2);">
      `;

      const checkbox = item.querySelector('input');
      checkbox.addEventListener('change', (e) => {
        if (typeof state.setColVisibility === 'function') state.setColVisibility(idx, e.target.checked);
        scheduleMergeRefresh(50);
      });

      list.appendChild(item);
    });

    modal.style.display = 'grid';
  });

  bindClick('colManagerCloseBtn', () => {
    const modal = $('colManagerModal');
    if (modal) modal.style.display = 'none';
    scheduleMergeRefresh(50);
  });
};

/** Sets up modal save/cancel bindings and overlay refresh. */
const setupModals = () => {
  bindClick('modalSaveBtn', () => {
    saveModalDetails(true);
    safeToast('Wijzigingen opgeslagen', 'save');
    scheduleMergeRefresh(50);
  });

  bindClick('modalCancelBtn', () => {
    const m = $('editModal');
    if (m) m.style.display = 'none';
  });
};

/** Subscribes to state changes and keeps the UI in sync. */
const setupStateSubscription = () => {
  const titleInput = $('boardTitle');

  if (typeof state.subscribe !== 'function') return;

  state.subscribe((_, meta) => {
    applyStateUpdate(meta, openEditModal);

    if (titleInput && state.project.projectTitle && document.activeElement !== titleInput) {
      titleInput.value = state.project.projectTitle;
    }

    document.title = state.project.projectTitle ? `${state.project.projectTitle} - SIPOC` : 'SIPOC Board';

    const header = $('board-header-display');
    if (header) {
      header.style.cursor = 'pointer';
      header.title = 'Dubbelklik om naam te wijzigen';
    }

    scheduleMergeRefresh(80);
  });
};

/** Sets up global hotkeys including sheet reorder and quick save. */
const setupGlobalHotkeys = () => {
  document.addEventListener('keydown', (e) => {
    const isSave = (e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 's';
    const isReorder = (e.ctrlKey || e.metaKey) && e.shiftKey && e.key.toLowerCase() === 'o';

    if (isSave) {
      e.preventDefault();
      syncOpenModal();
      saveToFile();
      safeToast('Quick Save', 'save');
      return;
    }

    if (isReorder) {
      e.preventDefault();
      reorderSheetsByPrompt();
      scheduleMergeRefresh(80);
      return;
    }

    if (e.key === 'Escape') {
      document.querySelectorAll('.modal-overlay').forEach((m) => (m.style.display = 'none'));
    }
  });
};

/** Sets up overlay resync for resize/scroll events. */
const setupOverlayResyncOnResize = () => {
  window.addEventListener('resize', () => scheduleMergeRefresh(0));
  window.addEventListener('scroll', () => scheduleMergeRefresh(0), true);
};

/** Initializes the application and renders the initial board state. */
const initApp = () => {
  initToast();
  setupDelegatedEvents();
  setupProjectTitle();
  setupSheetControls();
  setupToolbarActions();
  setupZoom();
  setupMenuToggle();
  setupColumnManager();
  setupModals();
  setupStateSubscription();
  setupGlobalHotkeys();
  setupOverlayResyncOnResize();
  
  // NEW: Koppel cloud acties
  setupCloudActions();

  renderBoard(openEditModal);

  const titleInput = $('boardTitle');
  if (titleInput) titleInput.value = state.project.projectTitle;

  scheduleMergeRefresh(120);

  setTimeout(() => safeToast('Klaar voor gebruik', 'info'), 500);
};

document.addEventListener('DOMContentLoaded', initApp);